#!/usr/bin/env node

'use strict';

var path = require('path');
var fs = require('fs-extra');
var gutil = require('gulp-util');
var program = require('commander');
var inquirer = require('inquirer');
var download = require('download-github-repo');
var async = require('async');
var del = require('del');
var pkg = require('../package');
var solis = require('..');

program.version(pkg.version);

/**
 * Serve project files
 */
program
  .command('serve')
  .description('parse and render project files into browser')
  .option('-q, --quiet', 'do not log task operations')
  .option('-r, --root <directory>', 'root directory of project')
  .action(function(options) {
    solis.serve({
      quiet: !!options.quiet,
      root: options.root || process.cwd(),
    });
  });

/**
 * Build project files into distribution format
 */
program
  .command('build')
  .description('build and minify code for distribution')
  .option('-q, --quiet', 'do not log task operations')
  .option('-r, --root <directory>', 'root directory of project')
  .option('-s, --serve', 'serve the compiled code')
  .action(function(options) {
    solis.build({
      quiet: !!options.quiet,
      root: options.root || process.cwd(),
      serve: !!options.serve,
    });
  });

/**
 * Deploy code to GitHub Pages
 */
program
  .command('deploy')
  .description('deploy files to a gh-pages branch')
  .option('-q, --quiet', 'do not log task operations')
  .option('-r, --root <directory>', 'root directory of project')
  .option('-c, --cname <url>', 'cname url')
  .option('-b, --build', 'run build before deploy')
  .action(function(options) {
    solis.deploy({
      quiet: !!options.quiet,
      root: options.root || process.cwd(),
      cname: options.cname,
      build: !!options.build,
    });
  });

/**
 * Generate code
 */
program
  .command('generate <name>')
  .alias('gen')
  .description('generate template files')
  .option('-r, --repo', 'the github repository name e.g. user-name/repo-name')
  .option('-q, --quiet', 'do not log task operations')
  .option('-o, --output <directory>', 'directory for output of generated files')
  .option('-t, --templates <directory>', 'directory of template modules')
  .action(function(name, options) {
    options.name = name;
    options.templates = (options.templates) ? path.resolve(process.cwd(), options.templates) : path.join(__dirname, '../templates');

    var series = [
      function(cb) {
        var file = path.join(options.templates, options.name, 'generate.json');
        try {
          var gen = fs.readJsonSync(file);
          inquirer.prompt(gen.questions, function(answers) {
            options.data = answers;
            cb();
          });
        } catch (e) {
          gutil.log('Generator questions not loaded from', gutil.colors.cyan(file));
          options.data = {};
          cb();
        }
      },
      function(cb) {
        solis.generate({
          quiet: !!options.quiet,
          dest: options.output || process.cwd(),
          src: options.src,
          data: options.data,
        }, cb);
      },
    ];

    // check if template is github repo or not
    if (options.name.indexOf('/') === -1) {
      options.src = path.join(options.templates, options.name);
      series.unshift(function(cb) {
        // check if template exists
        try {
          fs.statSync(path.join(options.templates, options.name));
        } catch (e) {
          gutil.log('Error', gutil.colors.red(options.name), 'template does not exist');
          process.exit(1);
        }
        cb();
      });
    } else {
      options.src = path.join(process.cwd(), '.template');
      series.unshift(function(cb) {
        download(options.name, options.src, function(err) {
          if (err) throw err;
          cb();
        });
      });
      series.push(function(cb) {
        del(options.src)
          .then(function() {
            cb();
          })
          .catch(function(error) {
            throw error;
          });
      })
    }

    async.series(series);
  });

program.parse(process.argv);
